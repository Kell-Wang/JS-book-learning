# 函数节流(throttle) 和 函数防抖(debounce)


## 目录(Catalog)
1. 函数防抖 (debounce)
1. 函数节流 (throttle) : 节流在 resize 事件中是最常用的
1. 两者的共同点:
1. 两者的区别:
1. 函数防抖完整代码



## 生词 (New Words)
- **parameter [pə'ræmɪtə] --n. 参数**
- **throttle ['θrɒt(ə)l] --n.节流(阀); 喉咙; 风门.**
- **debounce [di'bauns] --n.防抖**



## 内容(Content)
- Tips: js 高程上的函数节流写反了, 实际上是函数防抖.

### 函数防抖 (debounce)
- 概念: 当调用动作过 n 毫秒后, 才会执行该动作,
  若在 n 毫秒内又调用此动作则将重新计算执行时间.
- 防抖的原理是: 你尽管触发事件, 但是我一定在事件停止触发 n 秒后才执行.
  这意味着如果你在一个事件触发的 n 秒内又触发了这个事件, 那我就以新的事件触发的时间为准,
  在此时间 n 秒后才执行.总之, 就是要等你触发完事件 n 秒内不再触发事件, 我才执行.
  [参考文章](https://github.com/mqyqingfeng/Blog) 此页面下的 
  <JavaScript专题之跟着underscore学防抖>(tips: 这里的代码写的过于复杂, 不建议使用)

### 函数节流 (throttle) : 节流在 resize 事件中是最常用的
- 概念: 预先设定一个执行周期, 当调用动作的时刻大于等于执行周期则执行该动作,
  然后进入下一个新周期.

### 两者的共同点:
- 函数节流(throttle)和函数防抖(debounce)都是为了限制函数的执行次数,
  以优化函数触发频率过高导致的响应速度跟不上触发频率, 而出现延迟、假死或卡顿的现象.

### 两者的区别:
- 拿我们平时坐电梯为例来表述二者的区别:
    + 函数防抖: 如果有人进电梯 (触发事件), 那电梯将在 10s 钟后触发 (执行事件监听器),
      如果这时又有人进电梯了 (在 10s 内再次触发事件), 我们又得等 10s 再出发 (重新计时)
    + 函数节流: 保证如果电梯第一个人进来后, 10s 后准时运送一次, 这个时间从第一个人上电梯
      开始计时, 不等待, 如果没有人进来, 则不运行.


### 待做笔记:
- https://deskid.github.io/2017/12/08/throttle-vs-debounce/



### 函数防抖完整代码
- ```js
    let i = 0;
    function action() {
        // console.log("i++: ", i++);
        wrapper.innerHTML = count++;
    }
    function debounce(fn, wait) {
        let timeoutId;
        // - 是否是第一次调用
        let firstTime = true;
        return function() {
            let context = this;
            let args = arguments;
            // - 如果是第一次调用不需要延迟执行
            if (firstTime) {
                fn.apply(context, args);
                firstTime = false;
            }
            // - 如果 timeoutId 已经存在, 就清除 timeoutId 来阻止之前的调用被执行.
            // - Tip: 对比函数节流的代码可以看出, 函数节流和防抖也就这点不同.
            if (timeoutId) {
                clearTimeout(timeoutId);
            }
              // - 超时调用经过 wait 秒后执行其中的 fn 函数, context 改变函数的
              //   this 值, args 为接收的参数.
            timeoutId = setTimeout(function() {
                fn.apply(context, args);
            }, wait)
        }
    }
    let count = 1;
    let wrapper = document.getElementById("wrapper");
    wrapper.addEventListener("mousemove", debounce(action, 1000), false);
  ```


### 函数节流完整代码
- ```js
    // 代码来自: 《JavaScript 设计模式与开发实践》
    // fn: 需要被延迟执行的函数引用. wait: 延迟调用的时间
    function throttle(fn, wait) {
        // 定时器 (超时调用id)
        let timer;
        // 是否是第一次调用
        let firstTime = true;
        return function() {
            let args = arguments;
            let context = this;
            // 如果是第一次调用不需要延迟执行
            if (firstTime) {
                fn.apply(context, args);
                return firstTime = false;
            }

            // 如果定时器还在, 说明前一次延迟执行还没有完成
            if (timer) return;

            // 延迟一段时间执行
            timer = setTimeout(function() {
                // 首先清楚超时调用内 id
                clearTimeout(timer);
                timer = null;
                fn.apply(context, args);
            }, wait || 500)
        };
    }
    let i = 0;
    window.addEventListener("resize", throttle(function() {
        console.log("i++: ", i++);
    }, 500), false)
  ```
