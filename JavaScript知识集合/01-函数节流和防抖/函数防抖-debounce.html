<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>函数防抖</title>
    <style>
        * {
            margin: 0; padding: 0; list-style:none;
        }
        #wrapper{
            width: 80%; height: 200px; line-height: 200px;
            text-align: center;color: #fff;
            margin: 20px auto; border-radius: 10px;
            background-color: #444;
            font-size: 30px;
        }

    </style>
</head>
<body>
    <div id="wrapper"></div>

    <script type="text/javascript">
        // ## underscore 中的 debounce 防抖:
        // - 防抖的原理是: 你尽管触发事件，但是我一定在事件停止触发 n 秒后才执行。
        //   这意味着如果你在一个事件触发的 n 秒内又触发了这个事件，那我就以新的事件触发
        //   的时间为准，在此时间 n 秒后才执行。
        //   总之，就是要等你触发完事件 n 秒内不再触发事件，我才执行。

        // 在触发 DOM 上的某个事件时，会产生一个事件对象 event ，这个对象中包含着所有与
        // 事件有关的信息。包括导致事件的元素、事件的类型以及其他与特定事件相关的信息。
        // 例如，鼠标操作导致的事件对象中，会包含鼠标位置的信息，而键盘操作导致的事件对象中，
        // 会包含与按下的键有关的信息。所有浏览器都支持 event 对象。
        let i = 0;
        let count = 1;
        let wrapper = document.getElementById("wrapper");

        function action() {
            console.log("i++: ", i++);
            wrapper.innerHTML = count++;

            this.setAttribute("title", count++)
        }


        function debounce(fn, wait) {
            let timeoutId;
            // 是否是第一次调用
            let firstTime = true;

            console.log("timeout this: ", this);

            return function() {
                // this: <div id="wrapper">X</div>
                console.log("this: ", this);
                let context = this;
                let args = arguments;
                console.log("arguments: ", args);
                // 如果是第一次调用不需要延迟执行
                if (firstTime) {
                    fn.apply(context, args);
                    firstTime = false;
                }
                // 如果 timeoutId 已经存在，就清除 timeoutId 来阻止之前的调用被执行。
                // tips: 这里对比函数节流的代码就可以看到，实际上函数节流和防抖也就这点不同。
                if (timeoutId) {
                    clearTimeout(timeoutId);
                }
                // 超时调用经过 wait 秒后执行其中的 fn 函数，context 改变函数的 this
                // 值，args 为接收的参数。
                timeoutId = setTimeout(function() {
                    fn.apply(context, args);
                }, wait)
            }
        }


        wrapper.addEventListener("mousemove", debounce(action, 1000), false);

    </script>
</body>
</html>
