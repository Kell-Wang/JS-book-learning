## 第1章--面向对象的 javascript


1. 设计模式的定义是: 在面向对象软件设计过程中针对特定问题的简洁而优雅的解决方案。

#### 模式在不同语言之间的区别
   - 《设计模式》一书的副标题是"可复用面向对象软件的基础。"
   - 在 Java 这种静态编译型语言中，无法动态地给已存在的对象添加职责，所以一般通过包装类的方式来实现装饰着模式。
    但在 Javascript 这种动态解释型语言中，给对象动态添加职责是再简单不过的事情。这就造成了 javascript 语言的装饰者模式
    不在关注于给对象动态添加职责，而是关注于给函数动态添加职责。
    
#### 设计模式的适用性

#### 对 js 设计模式的误解
   - 实际上，在 java 等静态类型语言中，让子类来 "决定" 创建何种对象的原因是为了让程序迎合**依赖倒置原则** (DIP)。 在这些
    语言中创建对象时，先解开对象类型之间的耦合关系非常重要，这样才有机会在将来让对象表现出多态性。
   - 而在 js 这种类型模糊的语言中，对象多态性是天生的，一个变量既可以指向一个类，又可以随时指向另外一个类。 js 不存在类型耦合
    的问题，自然也没有必要刻意去把对象 "延迟" 到子类创建，也就是说， js 实际上不需要工厂方法模式的。
    

#### 第1章 面向对象的 Javascript
   - js 没有提供传统面向对象语言中的类式继承，而是通过原型委托的方式来实现对象与对象之间的继承。
  
#### 1.1 动态类型语言和鸭子类型
   - 编程语言按照数据类型大体可以分为两类: 1.静态类型语言。 2.动态类型语言。
   
#### 1.2 多态
   - "多态"一次源于希腊文 polymorphism, 拆开看是 poly (复数) + morph (形态) + ism, 从字面上我们可以理解为复数形态。
   多态的实际含义是: 同一操作作用于不同的对象上面，可以产生不同的解释和不同的执行结果。换句话说，
   给不同的对象发送同一个消息的时候，这些对象会根据这个消息分别给出不同的反馈。
        + 1st-面向对象的javascript.js
   - 1.2.7 设计模式与多态
        + GoF所著的 《设计模式》 一书的副书名是 "可复用面向对象软件的基础"。该书完全是从面向对象设计的角度出发的，
        通过对封装、继承、多态、组合等技术的反复使用，提炼出一些可重复使用的面向对象设计技巧。而多态在其中有时重中之重，
        绝大部分设计模式的实现都离不开多态性的思想。
   
#### 1.3 封装
   - 一般而言，我们讨论的封装是**封装数据**和**封装实现**，这一节将讨论更广义的封装 ，不仅包括封装数据和封装实现，还包括**封装类型**和**封装变化**
   - 1.3.1 封装数据
   - 1.3.2 封装实现
   - 1.3.2 封装类型
        + 封装类型是静态语言中一种重要的封装方式。一般而言，封装类型是通过抽象类和接口来进行的。
   - 1.3.4 封装变化
        + 《设计模式》一书中共归纳总结了 23 种设计模式。从意图上分，这23种设计模式分别会划分为创建型模式、结构型模式、和行为型模式。

### 1.4 原型模式和基于原型继承的 javascript 对象系统
   - 在以类为中心的面向对象编程语言中，类和对象的关系可以想象成铸模和铸件的关系，对象总是从类中创建而来。
    **而在原型编程的思想中，类并不是必需的，对象未必需要从类中创建而来，一个对象是通过克隆另外一个对象所得到的。**
    **原型模式不单是一种设计模式，也被称为一种编程泛型。**
   - 1.4.1 使用克隆的原型模式
        + 从设计模式的角度讲，原型模式是用于创建对象的一种模式，如果我们想要创建一个对象，一种方法是先指定它的类型，然后通过类来创建这个对象。
        原型模式选择了另外一种方式，我们不再关心对象的具体类型，而是找到一个对象，然后通过克隆来创建一个一模一样的对象。
        + 原型模式的实现关键是语言本身是否提供了 clone 方法。 ECMAScript 5 提供了 Object.create 方法，可以用来克隆对象。
            + 代码如下: P14-Object.create.js
        
  
#### 1.4.5   js 中的原型继承
   - js 也遵循原型编程的基本原则:
        + 1).所有的数据(js只能说是绝大部分数据)都是对象。
        + 2).要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。
        + 3).对象会记住它的原型。
        + 4).如果对象无法响应某个请求，它会吧这个请求委托给自己的原型。
       
   - 1).所有的数据都是对象
        + js中的根对象是 Object.prototype 对象。Object.prototype 对象是一个空的对象，我们在 js 中遇到的每个对象，
          实际上都是从 Object.prototype 对象克隆而来的，Object.prototype 对象就是他们的原型。例如下面的 obj1 和 obj2 对象:
            
        ```basic
            var obj1 = new Object();
            var obj2 = {};
            // 可以利用 ES5 提供的 Object.getPrototypeOf 来查看这两个对象的原型:
            console.log( Object.getPrototypeOf( obj1 ) === Object.prototype );      // true
            console.log( Object.getPrototypeOf( obj2 ) === Object.prototype );      // true
        ```
   - 2). 要得到一个对象，不是通过实例化类，而是找到一个对象作为原型并克隆它。
        + 用 new 运算符来创建对象的过程，实际上也只是县克隆 Object.prototype 对象，再进行一些其他额外操作的过程。
        在 Chrome 和 Firefox 等向外暴露了对象 _proto_ 属性的浏览器下，我们可以通过下面这段代码来理解 new 运算的过程。
            - P19-Object.prototype对象.js
    
   - 3). 对象会记住它的原型
        var a = new Object();
        console.log(a.__proto__ === Object.prototype);  // true
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
