<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>8.5 发布-订阅模式的通用实现</title>
</head>
<body>
    <script>

        // 我们把发布-订阅的功能提取出来，放在一个单独的对象内:
        var event = {
            // 缓存列表，存放订阅者的回调函数
            clientList: [],
            listen: function(key, fn) {
                // 如果还没有定阅过此类消息，给这类消息创建一个缓存列表
                /* 注: 当第一个 salesOffices.listen() 执行时 salesOffices 对象通过 for 循环
                 * 得到 event 对象中的 clientList 还是一个空数组，所以 this.clientList[key]
                 * 是 undefined */
                // console.log("this.clientList[key]: ", this.clientList[key]);    // undefined
                // console.log("!this.clientList[key]: ", !this.clientList[key]);  // true
                if (!this.clientList[key]) {
                    // 如果 !this.clientList[key] = true 就把一个空数组赋值给它
                    this.clientList[key] = [];
                }
                // 订阅的消息添加进消息缓存列表
                /** 这里有一个疑问: 控制台输出 clientList =[squareMeter88: Array(1), squareMeter100: Array(1)]
                 * 为什么数组内可以写成键值对的形式，而且此时 clientList.length = 0 ? 有一种可以理解的行为
                 * 就是虽然表面看到的是这样，但是浏览器或者 js 内部已经转换成了这种形式  clientList =
                 * {
                 *    squareMeter100: [function (){}],
                 *    squareMeter80: [function (){}]
                 * }
                 * */
                this.clientList[key].push(fn);
                // console.log("clientList", this.clientList);
            },
            trigger: function() {
                // (1) shift() 移除数组中的第一项，并返回该项，同时将数组的长度减 1.
                    // 取出消息类型
                var key = Array.prototype.shift.call(arguments),
                    // 取出该消息对应的回调函数集合
                    fns = this.clientList[key];
                // 如果没有绑定对应的消息 !fns 大概全等于 ( fns === false )
                // 如果没有订阅消息，则返回
                console.log("!fns: ", !fns);
                if (!fns || fns.length === 0) {
                    return false;
                }
                for (var i = 0, fn; fn = fns[i++]; ) {
                    // (2) arguments 是 trigger 时带上的参数
                    fn.apply(this, arguments);
                }
            }
        };
        var installEvent = function(obj) {
            for (var i in event) {
                obj[i] = event[i];
            }
        };

        // 再来测试一番，我们给售楼处对象 salesOffices 动态添加发布-订阅功能:
        var salesOffices = {};
        installEvent(salesOffices);
        // 小明订阅消息
        salesOffices.listen(
            "squareMeter88",
            function(price) {
                console.log("价格= " + price);
            }
        );
        // 小红订阅消息
        salesOffices.listen(
            "squareMeter100",
            function(price) {
                console.log("价格= " + price);
            }
        );
        salesOffices.trigger("squareMeter88", 2000000);   // 价格= 2000000
        salesOffices.trigger("squareMeter100", 3000000);  // 价格= 3000000
    </script>
</body>
</html>
