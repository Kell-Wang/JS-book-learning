# 第 8 章 -- 发布-订阅模式

## 本章目录 (Catalog)
- 8.1 现实中的 发布-订阅模式
- 8.2 发布-订阅模式的作用
- 8.3 DOM 事件
- 8.4 自定义事件
- 8.5 发布-订阅模式的通用实现
- 8.6 取消订阅的事件
- 8.7 真实的例子 - 网站登录
- 8.8 全局的发布-订阅对象
- 8.9 模块间通信
- 8.10 必须先订阅再发布吗
- 8.11 全局事件的命名冲突
- 8.12 JavaScript 实现发布-订阅模式的便利性
- 8.13 小结


## 生词 (New Words)
- **dependence [dɪ'pɛndəns] --n.[对...的]依赖, 依存[on, upon]**




## Added 
- 发布订阅模式简单实现
  ```js
    // - Dependence 收集订阅者 和 通知发布
    class Dep{
        constructor() {
            // + subs 数组为一个缓存列表, 用来存放和回调函数
            this.subs = [];
        }
        // - addSub 方法负责收集订阅者, 收集的订阅者是 Watcher 构造函数的实例.
        addSub(watcher) {
            this.subs.push(watcher);
        }
        // - notify 就是通知发布, 那么怎么发布呢? A: forEach 循环 subs 数组收集到的
        //   Watcher 构造函数的实例, 实例调用原型上的 update 方法.
        notify() {
             // + 数组的 slice() 方法, 创建当前数组的一个副本
            const subs = this.subs.slice();
            for (let i = 0, l = subs.length; i < l; i++) {
                subs[i].update();
            }
        }
        // - 移除一个订阅者 watcher
        removeSub(watcher) {
            remove(this.subs, watcher);
        }
    }

    // - Question: 下面 new Watcher(fn) 中添加的就是一个匿名函数, 那么这个 item
    //   是根据什么判断条件来执行移除的?
    function remove(arr, item) {
        if (arr.length) {
            const index = arr.indexOf(item);
            if (index > -1) {
                return arr.splice(index, 1);
            }
        }
    }

    // - 订阅者构造函数，我们默认规定每个构造函数的实例都有一个 update 方法,
    //   构造函数 Watcher 收到的 fn 为一个要添加的订阅者
    class Watch{
        constructor(fn) {
            this.fn = fn;
        }
        // - update 方法的目的就是执行当前构造函数调用时传入的订阅者(fn)
        update() {
            this.fn();
        }
    }

    let watcher = new Watcher(function() {
        console.log('我是一个订阅者 fn');
    });

    let dep = new Dep();
    dep.addSub(watcher);
    dep.addSub(watcher);
    console.log(dep.subs);
    dep.notify();
  ```
- **Tip: 自己写代码时还是下面书本上给出的示例更完整,易懂.**

## 本章内容 (Contents)
- `发布-订阅模式` 又叫 `观察者模式`，它定义对象间的一种一对多的依赖关系，当一个对象的状态
  发生改变时，所有依赖于它的对象都将得到通知。在 js 开发中，我们一般用 `事件模型` 来替代
  传统的发布-订阅模式。
### 8.1 现实中的 发布-订阅模式
### 8.2 发布-订阅模式的作用
- **(1)发布—订阅模式可以广泛应用于异步编程中，这是一种替代传递回调函数的方案.**  
  比如，我们可以订阅 ajax 请求的 error、 success 等事件。或者如果想在动画的每一帧
  完成之后做一些事情，那我们可以订阅一个事件，然后在动画的每一帧完成之后发布这个事件。
  在异步编程中使用发布—订阅模式，我们就无需过多关注对象在异步运行期间的内部状态，
  而只需要订阅感兴趣的事件发生点。
- **(2)发布—订阅模式可以取代对象之间硬编码的通知机制，一个对象不用再显式地调用另外**
  **一个对象的某个接口.**   
  发布—订阅模式让两个对象松耦合地联系在一起，虽然不太清楚彼此的细节，但这不影响
  它们之间相互通信。当有新的订阅者出现时，发布者的代码不需要任何修改；同样发布者
  需要改变时，也不会影响到之前的订阅者。只要之前约定的事件名没有变化，就可以
  自由地改变它们。
### 8.3 DOM 事件
- 实际上，只要我们曾经在 DOM 节点上面绑定过事件函数，那我们就曾经使用过发布—订阅模式，
  来看看下面这两句简单的代码发生了什么事情：
  ```js
    document.body.addEventListener('click', function() {
        console.log(2);
    }, false)
  ```
- 在这里需要监控用户点击 document.body 的动作，但是我们没办法预知用户将在什么时候点击.
  所以我们订阅 document.body 上的 click 事件，当 body 节点被点击时， body 节点便会
  向订阅者发布这个消息。这很像购房的例子，购房者不知道房子什么时候开售，于是他在订阅消息
  后等待售楼处发布消息。
### 8.4 自定义事件
- 除了 DOM 事件，我们还会经常实现一些自定义的事件，这种依靠自定义事件完成的发布—订阅模式
  可以用于任何 JavaScript 代码中。
- 现在看看如何一步步实现发布—订阅模式。
    + 首先要指定好谁充当发布者[`Dependence`]（比如售楼处）；
    + 然后给发布者添加一个缓存列表[`this.subs = []`]，用于存放(`addSub() 内添加`)
      回调函数(`Watcher 实例`) 以便通知订阅者（售楼处的花名册）；
    + 最后发布(`update()`)消息的时候，发布者会遍历(`notify() 中`)这个缓存列表，依次
      触发里面存放的订阅者回调函数（遍历花名册，挨个发短信）。
### 8.5 发布-订阅模式的通用实现
### 8.6 取消订阅的事件
### 8.7 真实的例子 - 网站登录
### 8.8 全局的发布-订阅对象
### 8.9 模块间通信
### 8.10 必须先订阅再发布吗
### 8.11 全局事件的命名冲突
### 8.12 JavaScript 实现发布-订阅模式的便利性
### 8.13 小结
