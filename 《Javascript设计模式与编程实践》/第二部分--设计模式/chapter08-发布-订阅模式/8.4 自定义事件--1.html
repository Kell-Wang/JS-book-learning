<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>8.4 自定义事件</title>
</head>
<body>
    <script>
        /** 8.4 自定义实现 发布-订阅者模式   P112
         * 1. 首先要制定好谁充当发布者。 (比如售楼处)
         * 2. 然后给发布者添加一个缓存列表，用于存放回调函数以便通知订阅者。 (售楼处的花名册)
         * 3. 最后发布消息的时候，发布者会遍历这个缓存列表，依次触发里面存放的订阅者回调函数 (遍历花名册，挨个发短信)
         *  另外我们还可以往回调函数里填入一些参数，订阅者可以接受这些参数。这是很有必要的，比如售楼处可以在发给订阅者的
         *  短信里加上房子的单价、面积、容器率等信息，订阅者接收到这些信息之后进行各自的处理。
         * */

            // 定义售楼处
        let salesOffices = {};
        // 缓存列表，存放订阅者的回调函数
        salesOffices.clientList = [];
        // 增加订阅者
        salesOffices.listen = function(fn) {
            // 订阅的消息添加进缓存列表
            this.clientList.push(fn);
        };
        // 发布消息
        salesOffices.trigger = function() {
            for (var i = 0, fn; fn= this.clientList[i++]; ) {
                // arguments 是发布消息时带上的参数
                fn.apply(this, arguments);
            }
        };

        // 下面我们来做一些简单的测试
        salesOffices.listen(function(price, squareMeter) {
            console.log("价格= " + price);
            console.log(squareMeter + "平方米");
        });
        salesOffices.listen(function(price, squareMeter){
            console.log("价格= " + price);
            console.log(squareMeter + "平方米");
        });

        // 注: trigger() 调用一次上面 listen() 方法就会执行2次，所以输出结果为: 2 次 (价格= 2000000  88平方米 )
        salesOffices.trigger(2000000, 88);

        // 输出结果: 2 次 (价格= 3000000  110平方米 )
        salesOffices.trigger(3000000, 110);

        /** 至此，我们已经实现了一个最简单的发布-订阅模式，但这里还存在一些问题。我们看到订阅者接收到了发布者发
         * 布的每个消息，虽然小明只想买 88 平方米的房子，但是发布者把 110 平方米的信息页推送给了小明，这对小明
         * 来说 是不必要的困扰。所以我们有必要添加一个表示 key, 让订阅者之订阅自己感兴趣的消息。 改写后的代码
         * 如 :  8.4 自定义消息--2.html */

    </script>
</body>
</html>
