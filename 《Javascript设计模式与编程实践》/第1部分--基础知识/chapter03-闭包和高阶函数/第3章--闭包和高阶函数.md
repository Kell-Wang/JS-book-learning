# 第 3 章 - 闭包和高阶函数

## 本章目录 (Catalog)
- 3.1 闭包 (closure)
    + 3.1.1 变量的作用域
    + 3.1.2 变量的生存周期
    + 3.1.3 闭包的更多作用
        - (1).封装变量
        - (2).延续局部变量的寿命
    + 3.1.4 闭包和面向对象设计
    + 3.1.5 用闭包实现命令模式
    + 3.1.6 闭包与内存管理

- 3.2 高阶函数
    + 高阶函数是指至少满足下列条件之一的函数：`(1) 函数可以作为参数被传递。`
      `(2) 函数可以作为返回值输出。`
    + 3.2.1 函数作为参数传递
        - 1.回调函数
        - 2.Array.prototype.sort: 接受一个函数当作参数，这个函数里面封装了数组元素的
          排序规则。
    + 3.2.2 函数作为返回值输出
        - 1.判断数据的类型
        - 2.getSingle
    + 3.2.3 高阶函数实现 AOP
    + 3.2.4 高阶函数的其他应用
        - (1) `函数柯里化(currying)`
        - (2) `uncurrying`
        - (3) `函数节流`
        - (4) 分时函数
        - (5) 惰性加载函数
#### 3.3 小结



## 本章内容 (Content)

#### 3.1 闭包 (closure)
- 3.1.1 变量的作用域
- 3.1.2 变量的生存周期
- 3.1.3 闭包的更多作用
    + 1.封装变量
        - ```js
            let cache = {};
            let num = 0;
            // - (1-0)、数组 join()方法：只接收一个参数，即用作分隔符的字符串，然后返回
            //   包含所有数组项的字符串。
            // - (1-1)、把参数转换成一个字符串: 比如现在 args = "3,6,9"
            let multiply = function () {
                // - (1-0)、(1-1)
                let args = Array.prototype.join.call(arguments, ",");
                // - (2)、当第二次调用时 cache 下面已经保存了 {"3,6,9": 162}
                if (cache[args]) {
                    return cache[args];
                }

                console.log(num++);
                console.log("cache: ", cache);

                let a = 1;
                for (let i = 0, l = arguments.length; i < l; i++) {
                    a = a * arguments[i];
                }
                return cache[args] = a;
            };

            console.log(multiply(3, 6, 9)); // 162
            console.log(multiply(3, 6, 9)); // - 重复调用就会走上面的 cache 不会再重新算一遍。
            console.log(multiply(2, 4, 5)); //

            console.log(multiply(3, 6, 9)); // 162
          ```
    + 2.延续局部变量的寿命
- 3.1.4 闭包和面向对象设计
    + 过程与数据的结合是形容面向对象中的 "对象" 时经常使用的表达。对象以方法的形式包含了
      过程，而闭包则是在过程中以环境的形式包含了数据。通常用面向对象思想能实现的功能，用
      闭包也能实现。反之亦然。在 js 语言的祖先 Scheme 语言中，甚至都没有提供面向对象的
      原生设计，但可以使用闭包来实现一个完整的面向对象系统。下面来看看这段跟闭包相关的代码：
      ```js
        let extent = function() {
            let value = 0;
            return {
                call: function() {
                    value++;
                    console.log(value);
                }
            }
        };
        extent.call();  // 1
        extent.call();  // 2

        extent.call();  // 3

        // ~~~~~~ 如果换成面向对象的写法，就是: ~~~~~~

        let scope = {
            value: 0,
            call: function() {
                this.value++;
                console.log(this.value);
            }
        };
        scope.call();
        scope.call();
        scope.call();

        let prize = Math.floor(Math.random() * 12);
        console.log("prize",prize)
      ```
- 3.1.5 用闭包实现命令模式
  
    + 详见:`./3.1 闭包/3.1.5-用闭包实现命令模式.html`
- 3.1.6 闭包与内存管理
    + 局部变量本来应该在函数退出的时候被解除引用，但如果局部变量被封闭在闭包形成的环境中，
      那么这个局部变量就会一直生存下去。从这个意义上看，闭包的确会使一些数据无法被及时销毁。
      使用闭包的一部分原因是我们选择主动把一些变量封闭在闭包中，因为可能在以后还需要使用这
      些变量，把这些变量放在闭包中和放在全局作用域，对内存方面的影响是一致的，这里并不能说
      成是内存泄露。如果在将来需要回收这些变量，我们可以手动把这些变量设置为 null。
    + 跟闭包和内训泄露有关系的地方是，使用闭包的同时比较容易形成循环引用，如果闭包的作用域链
      中保存着一些 DOM 节点，这时候就有可能造成内存泄露。但这本身并非闭包的问题，也并非 JS
      的问题。......
    + 同样，如果要解决循环引用带来的内存泄露问题，我们只需要把循环应用中的变量设置为 null 
      即可。将变量设置为 null 意味着切断变量与它此前引用的值之间的连接。当垃圾收集器下次
      运行时，就会删除这些值并回收它们占用的内存。


#### 3.2 高阶函数
- 高阶函数是指至少满足下列条件之一的函数：`(1) 函数可以作为参数被传递。`
  `(2) 函数可以作为返回值输出。`
- 3.2.1 函数作为参数传递
    + 把函数当做参数传递, 这代表我们可以抽离出一部分容易变化的业务逻辑, 把这部分业务逻辑放在
      函数参数中, 这样一来可以分离业务代码中变化与不变的部分。其中一个重要应用场景就是常见的
      回调函数。
    + 1.回调函数: 
        - ```js
            // -示例1: Ajax 回调函数
            let getUserInfo = function(userId, callback) {
                $.get('http://xxx.com/getUserInfo?' + userId, function(data) {
                    if (typeof callback === 'function') {
                        callback(data);
                    }
                })
            };
            // getUserInfo(13157, function(data) {
            //     console.log(data.userName);
            // });

            // ------

            // - 示例2: 在页面中创建 100 个 div 节点，然后把这些 div 节点都设置为隐藏。
            // - Tip: 此示例内部有 DOM 操作，只能在 HTML 中执行。
            (function() {
                let appendDiv = function(callback) {
                    for (let i=0; i < 100; i++) {
                        let div = document.createElement('div');
                        div.innerHTML = i;
                        document.body.appendChild(div);
                        if (typeof callback === "function") {
                            callback(div);
                        }
                    }
                };
                // - 我们把 div.style.display = 'none' 抽出来，用回调函数的形式传入 
                //   appendDiv 方法：
                appendDiv(function(node) {
                    node.style.display = 'none';
                });
            })();

            // ------

            // - 示例3: 把函数作为参数传递
            // - Tip:（来自汤姆大叔的博客--《深入理解JavaScript系列》（16）: 
            //   闭包（Closures））讲解 把匿名函数传入到 exampleFunc 和把一个匿名函数
            //   赋值给变量 funArg 是一个道理。
            (function() {
                function exampleFunc(funArg) {
                    funArg();
                }
                exampleFunc(function() {
                    console.log("我是被当做参数传递的函数");
                });
            })();
          ```
    + 2.`Array.prototype.sort()`
        - Array.prototype.sort() 接受一个函数当参数，这个函数里面封装了数组元素的顺序规则.
        - ```js
            let arr = [1, 3, 13, 5, 4, 6, 2, 9];

            // - 从小到大排列
            arr.sort(function(a, b) {return a - b;});
            // arr: [1, 2, 3, 4, 5, 6, 9, 13]
            console.log("arr: ", arr);

            // - 从大到小排列
            arr.sort(function(a, b) {return b - a;});
            // arr2: [13, 9, 6, 5, 4, 3, 2, 1]
            console.log("arr2: ", arr2);
          ```
- 3.2.2 函数作为返回值输出
    + 1.判断数据的类型
        - `Object.prototype.toString.call(obj)`: 通过获取 Object 原型上的 
          toString方法，让方法中的 this 变为需要检测的数据类型，并且让方法执行。
          ```js
            const obj = {name: "WANG"};
            const str = "250";
            const bool = true;
            const arr = [20, 30];
            console.log(Object.prototype.toString.call(obj));     // [object Object]
            console.log(Object.prototype.toString.call(str));     // [object String]
            console.log(Object.prototype.toString.call(bool));    // [object Boolean]
            console.log(Object.prototype.toString.call(arr));     // [object Array]

            // 简单封装
            let getType = function(obj) {
                return Object.prototype.toString.call(obj)
            };

            // getType(str): [object String]
            console.log("getType(str):", getType(str));
          ```
    + 2.getSingle
        - 下面是一个单例模式的例子，在第 3 部分设计模式的学习中，我们将进行更深入的讲解，
          这里暂且只了解其代码实现:
          ```js
            var getSingle = function(fn) {
                var ret;
                return function() {
                    return fn || (ret = fn.apply(this, arguments));
                }
            }
          ```
        - 这个高阶函数的例子, 既把函数当做参数传递, 又让函数执行后返回了另外一个函数. 我们
          可以看看 getSingle 函数的效果: 
          ```js
            var getScript = getSingle(function() {
                return document.createElement("script");
            });
            var script1 = getScript();
            var script2 = getScript();
            console.log(script1 === script2);   // true
          ```
- 3.2.3 高阶函数实现 AOP
    + AOP(面向切面编程)的主要作用是把一些跟核心业务逻辑模块无关的功能抽离出来，这些跟业务
      逻辑无关的功能通常包括 "日志统计、安全控制、异常处理"等。 把这些功能抽离出来之后，再
      通过"动态织入" 的方式掺入业务逻辑模块中。
    + 在 Java 语言中，可以通过反射和动态代理机制来实现 AOP 技术。 而在 js 这种动态语言中
      ，AOP 的实现更加简单，这是 js 与生俱来的能力。
    + 通常，在 js 中实现 AOP，都是把一个函数 "动态织入" 到另外一个函数之中，具体的
      实现技术有很多，本节通过扩展 `Function.prototype` 来做到这一点。 实现代码:
      ```js
        Function.prototype.before = function(beforefn) {    // {1}
            // - 保存原函数的引用
            let _self = this;                           // {2}
            // - 返回包含了原函数和新函数的 "代理" 函数
            return function() {
                // - 执行新函数, 修正 this
                beforefn.apply(this, arguments);        // {3}
                // - 执行原函数
                return _self.apply(this, arguments);    // {4}
            }
        };
        Function.prototype.after = function(afterfn) {  // {5}
            let _self = this;   // {6}
            return function() {
                let ret = _self.apply(this, arguments); // {7}
                afterfn.apply(this, arguments);         // {8}
                return ret;                             // {9}
            }
        };

        let func = function() {         // {10}
            console.log(2);             // {11}
        };
        func = func.before(             // {12}
            function() {console.log(1)} // {13}
        );
        func = func.after(              // {14}
            function() {console.log(3)} // {15}
        );
        func();                         // {16}
      ```
    + 上面代码执行注解: 
        0. Tip: 书上的 func = func.before().after() 等同于上面{12} 和 {14} 行的
          分开写法, 为了方便添加注释改成单独调用. 
        1. 先按执行顺序来看代码的执行, 行{1} 和 行{5} 的方法添加在 Function 
          构造函数的原型上, 在 {12} 和 {14} 行代码执行时被调用.
        2. 接下来看 行{10}, 使用 函数表达式 定义一个函数 (func 为函数名).  
            + Note: 补充说明, 在《JavaScript高级程序设计》的 `5.5 Function 类型`
              一节中明确指出: `在 ECMAScript 中函数实际上是对象. 每个函数都是`
              `Function 类型的实例,而且都与其他引用类型一样具有属性和方法.` 行{10}
              的写法使用 `Function 构造函数` 定义函数的方式可以写成:
              `let func = new Function("console.log(2)")` 但书上不建议此种
              方式定义函数, `因为这样会导致解析 2 次代码 (第一次是解析常规 ECMAScript`
              `代码, 第二次是解析传入构造函数中的字符串从而影响性能.) 不过, 这种语法`
              `对于理解 "函数是对象, 函数名是指针" 的概念是非常直观的.`
        3. 行{12} 把 func.before() 再次赋值给 func, 此时 Function 原型
          上的 before() 方法被调用, 现在我们进入 before() 方法内, 看看代码的执行,
          首先 行{2} 声明一个 `_self` 变量, 用来保存 `this`(原函数: 即 行 {10}
          的 Function 构造函数的实例), 接着执行 return 语句, 此处需要指出的是, 
          return 返回的实际上是一个闭包 
          (`闭包: 即有权 访问另一个函数作用域中变量的函数`), 
          在 return 返回的函数内部 行{3} 和 行{4} 引用的 this 都
          指向 行{10}, beforefn 为 before() 调用时传入的匿名函数(行 {13}); 同样
          before() 执行完毕后同样 return 一个闭包到全局执行环境(浏览器中为 window).
        4. 我们继续看 行{14}, 此处是调用 Function 构造函数上的 after() 方法, 
          同样我们进入方法内部去看, 首先是 行{6}, 行{6} 和 before 方法内的 行{2}
          一样, 但注意 _self 指向的 this 却是不同的, 这里的 this 指向是 Function
          构造函数原型上的 before() 方法执行完毕后返回的匿名函数 (在代码中 console 
          查看), 而 before() 方法内的 this 指向的是 行{10} (Function 
          构造函数的实例). 接下来 return 照样返回一个匿名函数到全局执行环境.
        5. 最后我们执行 行{16} 调用 func(); 到这里是不是炸了锅, 现在代码该走
          哪一步呢? 少年莫慌, 听老衲细细道来, 经过 {10}, {12}, {14} 行的代码后,
          func(函数名是指针) 指针前后指向了 3 个匿名函数;  
          此处需要指出的是, func 指针指向的 3 个匿名函数被以 `栈` 数据结构 的形式
          推入到浏览器中一个被称为 `call stack (执行栈)` 的容器中, (tip: 在浏览器
          控制台中可以查看 call stack);  
          栈的执行顺序是 后进先出(Last-in-First-out)的, 执行 func()
          根据代码的执行顺序, 首先执行 func.after() 返回的匿名函数, 也就是栈尾
          (类似于数组的 arr[2]) 的匿名函数, 我们进入到匿名函数内部看一下执行代码,
          首先是 行{7}, 由于 _self 指向的是 before() 方法返回的函数
          (即:栈中第二个匿名函数), 
          所以 行{7} `_self.apply() = function(beforefn.apply()...)()` 
          这样在按照 行{3}-> 行{4} -> 行{11} -> 行{8} -> 行{9} 的顺序执行
          所有代码;  
          最后 行{9} return 返回的是神马, 我也不知道, 我输出看了为 undefined. 
          懵逼中...o((⊙﹏⊙))o
    + 这种使用 AOP 的方式来给函数添加职责，也是 JavaScrip t语言中一种非常特别和巧妙的
      `装饰者模式`实现。这种装饰者模式在实际开发中非常有用，我们将在第 15 章进行详细讲解.  
- 3.2.4 高阶函数的其他应用
    + (1) `函数柯里化 （function currying）`
        - currying 又称部分求值。一个 currying 的函数首先会接受一些参数，接受了这些参数
          之后，该函数并不会立即求值，而是继续返回另外一个函数，刚才传入的参数在函数形成的闭包
          中被保存起来。待到函数被真正需要求值的时候，之前传入的所有参数都会被一次性用于求值。
    + (2) `uncurrying`
    + (3) `函数节流`
        - 详细讲解见: ``js-sundry-goods/20190224-函数节流和防抖`
    + (4) 分时函数
    + (5) 惰性加载函数

#### 3.3 小结
