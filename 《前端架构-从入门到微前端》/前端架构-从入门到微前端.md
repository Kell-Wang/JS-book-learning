# 《前端架构-从入门到微前端》


## 生词
- **retrieve [rɪ'triːv] --n.取回，回复  v.回收，检索(储存的信息)**
- **architecture ['ɑ:kitektʃə] --n.建筑，结构**
- **concept ['kɒnsept] --n.概念，观念** 
- **session ['seʃn] --会议, 学期**
---



> 前言
- 过去, 当人们讨论架构时, 往往指的是后端架构. 对于只使用后端 API 的前端来看, 后端看上去像
  只做 `CRUD (增加 (Create), 读取查询(Retrieve), 更新(Update), 删除(Delete))`. 然而
  后端并不像看上去那么简单. 从架构层面考虑, 后端是要实现高并发和高可用的. 在多数情况下, 数据
  库是后端最大的瓶颈, 存储的时候要考虑**原子性**, **一致性**, **隔离性** 和 **持久性**.
  使用的时候要考虑通过分表, 存储, 主从同步来提高性能和并发量, 在这个过程中还要考虑备份,迁移,
  查询速度, 效率等问题. 此外,在代码实现上还有一系列的复杂问题, 使用消息队列来解耦依赖, 使用
  微服务来拆分单体应用...
- 架构, 在前段会更复杂 -- 涉及领域更广. 前端在实现的过程中, 除了考虑代码的可用性, 性能, 
  模型构建, 组件复用等问题, 还有前端特有的平台设定, 浏览器兼容, 交互设计, 用户体验等问题, 
  而在 "大前端" 的背景之下, 还需要深入移动端设计, 桌面应用, 物联网等相关的领域.
- 规范, 原则, 模式, 架构, 是我们在前端架构中需要关注的内容.


> **目录 (Table of Content)**
- 第 1 章 -- 前端架构
    + 1.1 为什么需要软件架构
        - 1.1.1 什么是软件架构?
        - 1.1.2 开发人员需要怎样的软件架构
    + 1.2 架构的设计
        - 1.2.1 收集架构需求
        - 1.2.2 架构模式

        - 1.2.3 架构设计方法
        - 1.2.4 生成架构产出物
    + 1.3 架构设计原则
        - 1.3.1 不多也不少
        - 1.3.2 演进式
        - 1.3.3 持续性
    + 1.4 前端架构发展史
    + 1.5 前端架构设计: 层次设计
        - 1.5.1 系统内架构 
        - 1.5.2 应用级架构
        - 1.5.3 模块级架构
        - 1.5.4 代码级: 规范与原则
    + 1.6 小结
- 第 2 章 -- 项目中的技术架构实施
    + 2.1 技术负责人与架构
    + 2.2 技术准备期: 探索技术架构
        - 2.2.1 架构设计
        - 2.2.1 概念验证: 架构的圆形证明
        - 2.2.1 迭代 0: 搭建完整环境
        - 2.2.1 示例项目代码: 体现规范与原则
    + 2.3 业务回补期: 应对第一次 Deadline
        - 2.3.1 追捕业务 
        - 2.3.2 测试: 实践测试策略
        - 2.3.3 上线准备
        - 2.3.4 第一次部署: 验证部署架构 
        - 2.3.5 提升团队能力
    + 2.4 成长优化期: 技术负债与演进
        - 2.4.1 偿还技术负债
        - 2.4.2 优化开发体验
        - 2.4.3 带来技术挑战
        - 2.4.4 架构完善及演进
    + 2.5 小结
- 第 3 章 -- 架构基础: 工作流设计
    + 3.1 代码之旅: 基础规范
    + 3.2 代码组织决定应用架构
    + 3.3 统一代码风格, 避免架构腐烂
        - 3.3.1 命名法
        - 3.3.2 CSS 及其预处理器命名规范
        - 3.3.2 组件命名规则
    + 3.4 使用 Lint 规范代码
    + 3.5 规范化命名, 提升可读性
    + 3.6 规范开发工具, 提升开发效率
    + 3.7 项目的文档化: README 搭建指南
    + 3.8 绘制架构图: 减少沟通成本
        - 3.8.1 代码生成
        - 3.8.2 专业工具 
        - 3.8.3 附件附带工具
        - 3.8.4 在线工具
    + 3.9 可编辑文档库: 提升协作性
    + 3.10 记录架构决策: 轻量级架构决策记录
    + 3.11 可视化文档: 注重代码的可读性
    + 3.12 看板工具: 统一管理业务知识
    + 3.13 提交信息: 每次代码提交文档化
        - 3.13.1 项目方式
        - 3.13.2 开源项目方式
        - 3.13.3 对比不同文档方式
    + 3.14 通过流程化提高代码质量
        - 3.14.1 代码预处理
        - 3.14.2 手动检视代码
    + 3.15 使用工具提升代码质量
        - 3.15.1 代码扫描工具
        - 3.15.2 IDE 快速重构
    + 3.16 测试策略
        - 3.16.1 单元测试
        - 3.16.2 组件测试
        - 3.16.3 契约/接口测试
    + 3.17 小结
- 第 4 章 -- 架构基础: 设计构建流
- 第 5 章 -- 架构设计: 多页面应用
    + 5.1 为什么不需要单页面应用
        - 5.1.1 构建成本 
        - 5.1.2 学习成本
        - 5.1.3 后台渲染成本
        - 5.1.4 应用架构的复杂性
    + 5.2 简单多页面应用的开发
        - 5.2.1 选择 UI 库及框架
        - 5.2.2 jQuery 和 Bootstrap 仍然好用
        - 5.2.3 不使用框架: You Don't Need XX... 
    + 5.3 复杂多页面应用的开发
        - 5.3.1 模板与模板引擎原理
        - 5.3.2 基于字符串的模板引擎设计
        - 5.3.3 基于 JavaScript 的模板引擎设计
        - 5.3.4 双向绑定原理及实践
        - 5.3.5 前端路由原理及实践
        - 5.3.6 两种路由类型
        - 5.3.7 自造 Hash 路由管理器
    + 5.4 避免散弹式架构
        - 5.4.1 散弹式架构应用
        - 5.4.2 如何降低散弹性架构的出现频率
    + 5.5 小结
- 第 6 章 -- 架构设计: 单页面应用
- 第 7 章 -- 架构设计: 组件化架构
- 第 8 章 -- 架构设计: 前后端分离架构
- 第 9 章 -- 架构设计: 微前端架构
- 第 10 章 -- 微前端实战
- 第 11 章 -- 架构演进: 演进式架构

---

## 第 1 章 -- 前端架构
> 没有一种架构可以满足未来的需求.
### 1.1 为什么需要软件架构
- 1.1.1 什么是软件架构 
    + `Wiki: 软件架构是有关软件整体结构与组件的抽象描述, 用于指导大型软件系统`
      `各个方面的设计.`
    + `软件架构是指软件系统的高级结构, 以及创建这种结构和系统的约束, 每个结构包含`
      `软件元素, 元素之间的关系, 以及元素和关系的属性. 软件系统的架构时一种隐喻,`
      `类似于构筑物的体系结构. 它作为系统和开发项目的蓝图, 列出了设计团队必须执行`
      `的任务.`
- 1.1.2 开发人员需要怎样的软件架构
### 1.2 架构的设计
- 1.2.1 收集架构需求
- 1.2.2 架构模式
    + (1) 架构风格
        - (a) **分层风格**: 这是最常见的架构风格, 他将系统按照水平切分的方式分成多个层. 一个
          系统有多层组成, 每层由多个模块组成. 每一层为上层提供服务, 并使用下层提供的功能,
          最为人知的分层架构应用是 `OSI 七层模型` 和 `TCP/IP 五层模型`, 在开发后端服务
          的时候得到了广泛的应用. 如在采用 Spring MVC 开发的后端应用中, Controller 层
          在接收后端请求时, 将通过 Service 层向 DAO (Data Access Object, 数据访问对
          象) 层请求数据, 而不是直接向 DAO 层请求数据.
        - (b) **MVC 架构风格**: 这种风格应用的相当广泛, 他强调职责分离, 将软件系统分为
          三个基本部分: `模型 (Model), 视图 (View) 和 控制器(Controller)`. 由视图
          和控制器一起完成用户界面的功能, 并设计一套变更机制, 来保证用户界面与模型的一致性.
          它是一种常见的架构风格, 在设计图形界面时, 往往都有他的身影, 如前端应用,移动端应
          用等.
        - (c) **发布-订阅风格**
        - (d) **管理和过滤器**: 这是一种适合于处理数据流的架构模式, 它将每个步骤都封装在
          一个过滤器组件中, 数据通过相邻过滤器之间的管道传输. 最典型的管道-过滤器架构是
          UNIX shell 的设计. 在类 Unix 系统中, 使用 "|" 作为管理符号, 当我们需要编写
          复杂的 Shell 脚本来处理内容时, 便会使用这个符号. 诸如 `ls-l|grep.jpg`, 便
          会限制性 `ls-l` 命令, 再将结果交由 `grep` 程序, 查找以 .jpg 结尾的文件名. 它
          也适用于相关的数据处理场景, 如我们在采用 Hadoop, Spark 等编写数据处理相关的代码
          时, 便会采用这种模式来编写. 如前端框架的 Angular, 也直接内置了管理 (Pipe) 系统. 
- 1.2.3 架构设计方法
    + (1) 架构开发方法: `4 + 1 视图法`
    + (2) 架构开发方法: 
        `TOGAF (The Open Group Architecture Framework, 开放组体系结构框架)` 的标准
        化方法来设计企业架构. 从 1995 年发布第一个版本至今, 已经发布了 9 个版本 -- 在笔者
        写本书的时候, 最新版本是 9.2 版本, 该版本将企业架构分为如下 4 个架构域
        (Architecture Domains).
        - 业务架构 (Business Architecture)
        - 应用架构 (Application Architecture)
        - 数据架构 (Data Architecture)
        - 技术架构 (Technology Architecture)
- 1.2.4 生成架构产出物
### 1.3 架构设计原则
- 1.3.1 不多也不少
- 1.3.2 演进式
- 1.3.3 持续性
### 1.4 前端架构发展史
- P21: 微前端解决了一下问题:
    + 跨框架. 在一个页面上运行, 可以同时使用多个前端框架
    + 应用拆分. 将一个复杂的应用拆解为多个微小的应用, 类似于微服务.
    + 遗留系统迁移. 让旧的前端框架, 可以直接嵌入到现有的应用运行.
### 1.5 前端架构设计: 层次设计
- 1.5.1 系统内架构 
    + P23: 前后端分离架构其实是一个笼统的概念, 它指前后端分离如何实施的技术决策. 它包含了
      一系列的决策, `用户鉴权`, `API 接口管理与设计`, `API(契约)文档管理`, 
      `Mock Server 使用`, `BFF (服务于前端的后端)`, `是否需要服务器端渲染`等.
    + 当在一个系统内时, 微前端是一个应用间的架构方案, 当在多个应用间时, 微前端则是一种系统
      间的架构方案.
    + 微前端是将多个前端应用以某种形式结合到一起, 当系统中存在多个前端应用(或者单个前端应用
      的模块较大)时, 就需要考虑使用微前端的方式来拆分.
    + 然后, 我们还需要考虑前端的客户端展现形式. 在大前端的背景下, 他可能是 PC Web 应用, 
      移动 Web 应用, 混合移动应用 (结合 Cordova 架构), 混合桌面应用 (结合 Electron
      框架), 原生移动应用 (结合 React Native)等, 具体选择那一种技术, 取决于我们先前调查
      的利益相关者的需要. 当我们做完上述三个核心的架构决策之后, 就需要考虑应用的部署架构了.
      有的客户端形式可能需要服务端渲染, 会在某种程序上影响到前端应用的部署, 但是总的影响并
      不大, 往往只需要通过反向代理的配置就可以完成配置. 如果与后台服务部在一个域, 则需要考
      虑支持跨域请求, 或者让后台做一层代理.

- 1.5.2 应用级架构
- 1.5.3 模块级架构
- 1.5.4 代码级: 规范与原则
### 1.6 小结
- > 参考书籍: <面向模式的软件架构> <架构实战: 软件架构设计的过程> <恰如其分的软件架构>



## 第 2 章 -- 项目中的技术架构实施
### 2.1 技术负责人与架构
### 2.2 技术准备期: 探索技术架构
- 2.2.1 架构设计
- 2.2.1 概念验证: 架构的原型证明
    + P30: `概念验证 (Proof of Concept 简称 PoC)`
- 2.2.1 迭代 0: 搭建完整环境
- 2.2.1 示例项目代码: 体现规范与原则
### 2.3 业务回补期: 应对第一次 Deadline
- 2.3.1 追捕业务 
- 2.3.2 测试: 实践测试策略
- 2.3.3 上线准备
- 2.3.4 第一次部署: 验证部署架构 
- 2.3.5 提升团队能力
    - P36: 能力的提升方式: 
        + <img src = "./aofe-1.images-master/ch02/architecture-in-team.jpg"
            style="display:block; margin-left:0; border: 1px solid #aaa;">
    - (1) 技术分享 (Sessions)
    - (2) 工作坊 (Workshop) 
    - (3) 面向新人的结对编程 
    - (4) 对内输出和对外输出
        + 输出是最好的输入方式       
### 2.4 成长优化期: 技术负债与演进
- 2.4.1 偿还技术负债
- 2.4.2 优化开发体验
- 2.4.3 带来技术挑战
- 2.4.4 架构完善及演进
### 2.5 小结
 

## 第 3 章 -- 架构基础: 工作流设计
- 略

## 第 4 章 -- 架构基础: 设计构建流
- 略

## 第 5 章 -- 架构设计: 多页面应用
### 5.1 为什么不需要单页面应用
- 5.1.1 构建成本 
- 5.1.2 学习成本
- 5.1.3 后台渲染成本
- 5.1.4 应用架构的复杂性
### 5.2 简单多页面应用的开发
- 5.2.1 选择 UI 库及框架
- 5.2.2 jQuery 和 Bootstrap 仍然好用
- 5.2.3 不使用框架: You Don't Need XX... 
### 5.3 复杂多页面应用的开发
- 5.3.1 模板与模板引擎原理
- 5.3.2 基于字符串的模板引擎设计
- 5.3.3 基于 JavaScript 的模板引擎设计
- 5.3.4 双向绑定原理及实践
    + 双向绑定, 即双向数据绑定, 它是指视图(view)的变化能实时地让数据模型(Model)发生变化,
      而数据的变化也能试试更新到视图层.
    + - `V: view 视图模板`. `M: Model 数据模型`. `VM: view-model 视图模型` 
- 5.3.5 前端路由原理及实践
- 5.3.6 两种路由类型
- 5.3.7 自造 Hash 路由管理器
### 5.4 避免散弹式架构
- 5.4.1 散弹式架构应用
- 5.4.2 如何降低散弹性架构的出现频率
### 5.5 小结

## 第 8 章 -- 架构设计: 前后端分离架构
- 8.4 服务于前端的后端 BFF
    + 8.4.1 为什么使用 BFF?
        - BFF (Backends for Frontends 服务于前端的后端), 是指在服务器设计 API 时会
          考虑客户端的使用情况, 在服务端根据不同的设备类型返回不同客户端所需要的结果. BFF
          模式不会为所有的客户端创建通用的 API, 而是创建多个 BFF 服务.
    + 8.4.2 前后端如何实现 BFF
    + 8.4.3 使用 GraphQL 作为 BFF
        - P224: 与普通的 Node.js + Web 框架实现 BFF 相比, 更流行的方式是采用 GraphQL. 
          GraphQL 即是一种用于 API 的查询语句, 又是一种标准, 也相当于一个满足开发者数据
          查询的运行时.
        - P225: 值得注意的是, GraphQL 只定义了这种查询语言语法, 语句如何执行等. GraphQL
          真正的实现则依赖于不用的服务端库.   

## 第 9 章 -- 架构设计: 微前端架构
- 9.1 微前端
    + 微前端是一种类似于微服务的架构, 它将微服务的理念应用于浏览器端, 即将单页面前端应用由
      单一的单体应用转变为把多个小型前端应用聚合为一的应用.各个前端应用还可以独立开发, 独立
      部署. 同时, 它们也可以进行并发开发 - 这些组件可以通过 NPM, GitTagGit 或者 
      Submodule 来管理.
