<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>promise 语法讲解</title>
</head>
<body>

<script>
    // 打印 Promise 可以看出其就是一个 构造函数
    // console.dir(Promise);

    function runAsync() {
        // resolve 是将 Promise 的状态设置为 fulfilled, reject 是将 Promise 的状态设置为 rejected.
        return new Promise(function (resolve, reject) {
            // 做一些异步操作
            setTimeout(function () {
                console.log("执行完成");
                // 把成功的内容传给  resolve, 以便在下面 then 的 fulfilled 时输出内容
                resolve("随便什么数据");
            }, 2000)
        });
    }

    // runAsync();
    runAsync().then(function (data) {
        console.log(data);
    });


    // ------ 仿写最基本的回调函数 ------
    /*function fnRunAsync(callback) {
        setTimeout(function () {
            console.log("执行1111");
            callback("回调执行222");
        }, 200)
    }
    fnRunAsync(function (data) {
        // 参数 data fnRunAsync内调用回到函数时传入的参数
        console.log(data);
        console.log("回调函数内的输出");
    })*/
    // ------ 仿写最基本的回调函数 ------


    /*let oObj = {
        run() {
            console.log(this);
        }
    };
    oObj.run();

    function run() {
        console.log(this);
    }
    run();
    run.apply(oObj);*/



    new Promise(
        // fn1
        (resolve, reject) => {
            try {
                fetch(url, (data) => { resolve(data) })
            } catch (e) { reject(e); }}
        ).then(
            // fn2
            (data) => { return JSON.stringify(data);},
            (e) => { return e }
        ).then(
            // f3
            (data) => { return data; },
            (e) => { return e; }
        );


    // Promise
    function Pro(fn) {
        // null: pending, true: fulfilled,  false: rejected
        let state = null;
        // 处理函数的参数
        let value = null;

        // 当前 promise 的处理函数和下一个 promise 状态转换函数
        let self = this;
        // promise 公开调用方法，串联所有异步操作
        this.then = (onFulfilled, onRejected) => {};

        // 执行成功处理函数 pending -> fulfilled
        function resolve(value) {}

        // 执行失败处理函数 pending -> rejected
        function reject(value) {}

        // 保存和执行 Promise 对象 deferreds 中的函数
        function handle(deferred) {}

        // deferreds 的下一项对象移动
        function final() {}

        doResolve(fn, resolve, reject)
        // 对状态转换时间处理函数进行封装后，再传给执行元素
    }


</script>
</body>
</html>
