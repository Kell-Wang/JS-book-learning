<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>promise 语法讲解</title>
</head>
<body>

<script>
    // 打印 Promise 可以看出其就是一个 构造函数
    // console.dir(Promise);

    function runAsync() {
        // resolve 是将 Promise 的状态设置为 fulfilled, reject 是将 Promise 的状态设置为 rejected.
        return new Promise(function (resolve, reject) {
            // 做一些异步操作
            setTimeout(function () {
                console.log("执行完成");
                // 把成功的内容传给  resolve, 以便在下面 then 的 fulfilled 时输出内容
                resolve("随便什么数据");
            }, 2000)
        });
    }

    // runAsync();
    runAsync().then(function (data) {
        console.log(data);
    });


    // ------ 仿写最基本的回调函数 ------
    /*function fnRunAsync(callback) {
        setTimeout(function () {
            console.log("执行1111");
            callback("回调执行222");
        }, 200)
    }
    fnRunAsync(function (data) {
        // 参数 data fnRunAsync内调用回到函数时传入的参数
        console.log(data);
        console.log("回调函数内的输出");
    })*/
    // ------ 仿写最基本的回调函数 ------


    /*let oObj = {
        run() {
            console.log(this);
        }
    };
    oObj.run();

    function run() {
        console.log(this);
    }
    run();
    run.apply(oObj);*/



    new Promise(
        // fn1
        (resolve, reject) => {
            try {
                fetch(url, (data) => { resolve(data) })
            } catch (e) { reject(e); }}
        ).then(
            // fn2
            (data) => { return JSON.stringify(data);},
            (e) => { return e }
        ).then(
            // f3
            (data) => { return data; },
            (e) => { return e; }
        );

    
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~


        // 例子: 写一个相加的函数，接受2个回调函数返回的数字相加。
        // 注釋: 第一步先執行 towNumPlus 函數，走到 consider 內時 a b 都是 undefined 所以會退出
        let twoNumPlus = function(callback) {
            let a, b;
            let consider = function() {
                if (a === undefined || b === undefined) { return; }
                callback(a + b);
            };


            /* 調用 oneNum() 函數，并把一個匿名函數当作参数传入，緊接著執行外面的
             * function oneNum(){} 函数，並且在函數內調用當做參數傳進來的匿名函數，調用的同时傳入
             * 一個參數 1, 接著就在当前环境中继续执行这个匿名函数中的内容(即其内部的:
             * a = _a, consider(); )  */
            oneNum(function(_a) {
                a = _a;
                consider();
            });
            oneOtherNum(function(_b) {
               b = _b;
               consider();
            });
        };

        function oneNum(oneCallback) {
            oneCallback(1);
        }

        function oneOtherNum(oneOtherCallback) {
            oneOtherCallback(2)
        }

        twoNumPlus(function(c) {
            console.log(c);
        });
   
    
    
    
    /*let fun = function (par) {
        console.log(par);
    }("传入的参数");

    // 错误写法，没有此语法
    function run(par) {
        console.log(par);
    }("参数");

    // IIFE (Immediately-invoked function expression)
    (function run(par) {
        console.log(par);
    })("参数");

    (function run(par){
        console.log(par);
    }("参数"));*/

</script>
</body>
</html>
