<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0,
          maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<script type="text/javascript">
    (function(scope) {
        const PENDING = 'pending';
        const FULFILLED = 'fulfilled';
        const REJECTED = 'rejected';
    
        class Promise{
            // - executor /ɪg'zekjʊtə/ n.执行器，执行者
            // - Tip: 我们把 new Promise(function(resolve, reject) {}) 传入的匿名函数
            //   称为执行器(executor)
            constructor(executor) {
                // - 确定 executor 是个函数
                if (executor && typeof executor !== 'function') {
                    throw new Error(`Promise resolve ${executor} is not a function`)
                }
                this.state = PENDING;
                this.data = undefined;
                // - 定义一个保存回调函数的数组
                this.callbackArr = [];
                if (typeof(executor) === 'function') {
                    // - 调用执行器 call Executor
                    this.callExecutor(executor);
                }
            }
            
            // - 定义执行构造器(call executor)
            callExecutor(executor) {
                const that = this;
                let cb = false;
                // - onSuccess 和 onError 只会执行一个，在构造函数的执行器(executor) 
                //   的函数体内只会传入其中一个。
                // - Tip: onSuccess/onError 在下面 try...catch 中被调用，value 参数
                //   是 执行器(executor) 的函数体中，调用当前 onSuccess() 传入的参数
                const onResolve = function(value) {
                    // - 如果 cb = true 立马退出
                    if (cb) {return}
                    cb = true;
                    // - execute ['eksɪkjuːt] --vt.执行，实施，履行
                    // - 我们从执行器(executor) 的函数体中({}),可以看出，是直接调用了当
                    //   前的 onResolve 或者下面的 onReject,
                    that.executeCallback('fulfilled', value);
                };
                const onReject = function(value) {
                    if (cb) {return}
                    cb = true;
                    that.executeCallback('rejected', value);
                };
                try {
                    // - 执行 new Promise() 传入的 executor(执行器)函数，并把上面定义的
                    //   onResolve 和 OnReject 函数传入其中。
                    executor(onResolve, onReject);
                } catch(e) {
                    // - new Promise() 中抛错，这里不用 that.executeCallback('reject',e)
                    //   ，有错误的话提前终止不进入 onSuccess / onError
                    onReject(e);
                }
            }
            
            // - status: fulfilled/rejected 
            executeCallback(status, value) {
                console.log("输出 resolve/reject 回调函数的传入的参数: ", value);
                // - Tip: type == 'fulfilled';
                const isResolve = status == 'fulfilled';
                let thenable;
                // - 如果 value 仍然是 对象 / 函数
                if (complete && Object.prototype.toString.call(value) 
                    === '[object Object]' || (value instanceof Function)) {
                    try{
                        thenable = this.getThen(value);
                    } catch(e) {
                        // - this 为当前构造函数的实例
                        return this.executeCallback.call(this, 'rejected', e);
                    }
                }
                // - 如果是 thenable 对象而且是 fulfilled 状态 (Promise.reject() 
                //   会返回参数值)
                if (isResolve && thenable) {
                    // -最终会将 thenable 对象里的值抽出到 this.data 中
                    this.callExecutor(thenable);
                } else if (this.state === PENDING) {
                    // - promise 状态一旦改变便不可更改
                    this.state = isResolve ? FULFILLED : REJECTED;
                    this.data = value;
                    this.callbackArr.forEach(fn => fn[status](value));
                }
                // - 直接调用 Promise.resolve() Promise.reject() 用得到
                return this;
            }
    
            // - 获取 thenable 对象
            // - thenable 指的是一个具有 .then 方法的对象。
            getThen(value) {
                // - 避免 then 内 get 方法多次的调用，对应特殊测试.html
                const then = value.then;
                if (Object.prototype.toString.call(value) === '[object Object]'
                    && typeof(then) === 'function') {
                    return function() {
                        then.apply(value, arguments);
                    }
                } else {
                    return false;
                }
            }
    
            executeAsyncCallback() {}
    
            then() {}
    
            catch() {}
    
            // - 非 ES6 标准
            done() {}
    
        }
    
        class CallbackItem {
    
        }
    
        // - Promise 类上添加的静态方法(类方法)
        Promise.resolve = function() {};
    
        Promise.reject = function() {};
    
        Promise.all = function() {};
    
        Promise.race = function() {};
    
        //
        Promise.deferred = Promise.defer = function() {};
    
        Promise.wrap = function() {};
    
        try {
            module.exports = Promise;
        } catch(e) {
            scope.Promise = Promise;
        }
    
    
    })(this);

    let promise = new Promise(function(resolve, reject) {
        console.log("看看当前 Executor 执行器有没有执行");
        let val = '我是传入 resolve 函数的值';
        resolve(val);
    });

    // new Promise(function(resolve, reject) {
    //     console.log(this);  // Window
    //     resolve("传入then 中的数据");
    // }).then(function(data) {
    //     console.log(data);
    //     console.log("then this", this); // window
    // });
    
    

    // - 语法: Object.create(proto, [propertiesObject]):
    // + (1) proto: 一个对象，应该是新创建的对象的原型。(具体来说就是要要赋值给构造函数的
    //     原型的对象)
    // + (2) propertiesObject: 可选。该参数对象是一组属性和值，该对象的属性名称将是新创建
    //   的对象的属性名称，值是属性描述符(这些属性描述符的结构与 Object.defineProperties()
    //   的第二个参数一样)。注意：该参数对象不能是 undefined,另外只有对象中自身拥有的
    //   不可枚举的属性才有效,也就是说该对象的原型链上的属性无效的。

    // - 对象含有 then 属性的测试
    let numberOfTimesThenWasRetrieved = 0;
    let obj = Object.create(null, {
        then: {
            get: function() {
                ++numberOfTimesThenWasRetrieved;
                return function(resolve) {
                    resolve();
                }
            }
        }
    })
    console.log('obj:', obj);
    Promise.resolve(obj).then(() => {
        console.log(numberOfTimesThenWasRetrieved); // 1
    });
</script>
</body>
</html>