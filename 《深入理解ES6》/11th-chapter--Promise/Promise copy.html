<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0,
          maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<script type="text/javascript">
    const PENDING = 'pending';
    const FULFILLED = 'fulfilled';
    const REJECTED = 'rejected';

    class Promise{
        constructor(executor) {
            if (executor && typeof executor !== 'function') {
                throw new Error(`Promise resolve ${executor} is not a function`)
            }
            this.state = PENDING;
            this.data = undefined;
            this.callbackArr = [];
            if (typeof(executor) === 'function') {
                this.callExecutor(executor);
            }
        }

        callExecutor(executor) {
            const that = this;
            let cb = false;
            const onSuccess = function(value) {
                if (cb) {return}
                cb = true;
                that.executeCallback('fulfilled', value);
            };
            const onError = function(value) {
                if (cb) {return}
                cb = true;
                that.executeCallback('rejected', value);
            };
            try {
                executor(onSuccess, onError);
            } catch(e) {
                onError(e);
            }
        }

        executeCallback(status, value) {
            const isResolve = status === 'fulfilled';
            let thenable;
            if (isResolve && Object.prototype.toString.call(value)
                    === '[object Object]' || (typeof (value) === 'function')) {
                try{
                    thenable = this.getThen(value);
                } catch(e) {
                    return this.executeCallback.call(this, 'rejected', e);
                }
            }
            if (isResolve && thenable) {
                this.callExecutor(thenable);
            } else if (this.state === PENDING) {
                this.state = isResolve ? FULFILLED : REJECTED;
                this.data = value;
                this.callbackArr.forEach(fn => fn[status](value));
            }
            return this;
        }

        getThen(value) {
            const then = value.then;
            if (Object.prototype.toString.call(value) === '[object Object]'
                    && typeof(then) === 'function') {
                return function() {
                    then.apply(value, arguments);
                }
            } else {
                return false;
            }
        }

        // - 执行异步回调
        executeAsyncCallback(callback, value) {
            const that = this;
            setTimeout(function() {
                let res;
                try {
                    res = callback(value);
                } catch (e) {
                    that.executeCallback('rejected', e);
                }
                if (res === that) {
                    that.executeCallback('rejected',
                            new TypeError('Chaining cycle detected for promise # <Promise>'));
                } else {
                    that.executeCallback('fulfilled', res);
                }
            }, 4)
        }

        then(onResolved, onRejected) {
            if ((typeof (onResolved) !== 'function' && this.state === FULFILLED)
                    || (typeof (onRejected) !== 'function' && this.state === REJECTED)) {
                return this;
            }
            const promise = new this.constructor();
            if (this.state !== PENDING) {
                const callback = this.state === FULFILLED ? onResolved : onRejected;
                this.executeAsyncCallback.call(promise, callback, this.data);
            }
            else {
                this.callbackArr.push(new CallbackItem(promise, onResolved, onRejected));
            }
            return promise;
        }

        catch(onRejected) {
            return this.then(null, onRejected);
        }

        // - 非 ES6 标准
        done(onResolved, onRejected) {
            this.then(onResolved, onRejected)
                    .catch((reason) => {
                        setTimeout(() => {
                            throw reason;
                        }, 0)
                    })
        }

    }

    class CallbackItem {
        constructor(promise, onResolved, onRejected) {
            this.promise = promise;
            this.onResolved = typeof (onResolved) === 'function' ? onResolved
                    : (v) => {return v;};
            this.onRejected = typeof (onRejected) === 'function' ? onRejected
                    : (err) => {throw err;}
        }

        fulfilled(value) {
            this.promise.executeAsyncCallback(this.onResolved, value);
        }

        rejected(value) {
            this.promise.executeAsyncCallback(this.onRejected, value);
        }
    }

    // - Promise 类上添加的静态方法(类方法)
    Promise.resolve = function(value) {
        console.log('resolve inner this:', this);
        if (value instanceof this) return value;
        return this.prototype.executeCallback.call(new Promise(), 'fulfilled', value);
    };

    Promise.reject = function(value) {
        if (value instanceof this) return value;
        return this.prototype.executeCallback.call(new Promise(), 'rejected', value);
    };

    Promise.all = function(arr) {
        const that = this;
        return new this(function(resolve, reject) {
            let res = [];
            let count = 0;
            let flag = false;
            arr.forEach((value, index) => {
                // - Tip: 这里不好理解，多看2遍。
                that.resolve(value).then((onResolved) => {
                    res[index] = onResolved;
                    count++;
                    if (count === arr.length) {
                        flag = true;
                        return resolve(res);
                    }
                }, (err) => {
                    flag = true;
                    return reject(err);
                })
            })
        })
    };


    function pms2() {
        return new Promise((resolve, reject) => {
            console.log("我是 pms2 内的内容");
            resolve(Promise.resolve('执行任务2成功'))
        })
    }

    let psm1 = function() {
        return new Promise(function(resolve, reject) {
            let val = '我是 psm1 的 value';
            resolve(val);
        })
    };
    psm1().then((data) => {
        console.log(data);
        return pms2();
    }).then((data) => {
        console.log(data);
    });


    // - Promise.all() 示例
    let createPromise = function(url) {
        return new Promise((resolve, reject) => {
            // - ajax() 方法见封装的 ajax 文件
            ajax({
                url: url,
                success(json) {
                    resolve(json);
                },
                error(err) {
                    reject(err);
                }
            })
        })
    };
    // Promise.all([
    //     // p01, p02
    //     createPromise('data/arr.txt'),
    //     createPromise('data/data.json')

    // ]).then(function(all) {
    //     let [arr, data] = all;
    //     console.log('arr: ' +arr);
    //     console.log('data: ' + data);
    // }, function(err) {
    //     console.log(`失败： ${err}`);
    // });

</script>
</body>
</html>