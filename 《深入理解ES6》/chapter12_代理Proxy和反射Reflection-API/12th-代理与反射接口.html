<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>12th-代理与反射接口</title>
</head>
<body>
<script>
    // #### 4.使用 set 陷阱函数验证属性 
    (function() {
        let tar = {
            name: "target"
        };
        let proxy = new Proxy(tar, {
            // - 4 个从参数见上面的文档解释
            // - receiver (本例中未使用) 等于 proxy.
            set(trapTarget, key, value, receiver) {
                // - 忽略已有属性，避免影响他们
                if (!trapTarget.hasOwnProperty(key)) {
                    if (isNaN(value)) {
                        // throw new TypeError("属性必须是数字");
                    }
                }
                // 添加属性
                return Reflect.set(trapTarget, key, value, receiver);
            }
        });

        // - 添加一个新属性
        proxy.count = 1;
        console.log(proxy.count);
        console.log(tar.count);

        // - 可以为 name 赋一个非数值类型的值，因为该属性已经存在. 用于接收属性的
        //   对象上已有的非数字属性仍然可以被操作.
        proxy.name = "proxy";
        console.log(proxy.name);
        console.log(tar.name);

        // 抛出错误
        proxy.anotherName = "proxy";
    })();

    
    // #### 5.使用 get 陷阱函数验证对象结构 (Object Shape)
    (function() {
        let proxy = new Proxy({}, {
            get(trapTarget, key, receiver) {
                if (!(key in receiver)) {
                    // throw new TypeError('属性 ' + key  + ' 不存在');
                }
                return Reflect.get(trapTarget, key, receiver);
            }
        });
        // - 添加一个属性, 程序仍正常运行
        proxy.name = 'proxy';
        console.log(proxy.name);    // "proxy"
        // - 如果属性不存在, 则抛出错误
        console.log(proxy.age);     // TypeError: 属性 age 不存在
    })();


    // #### 6.使用 has 陷阱函数隐藏已有属性
    (function() {
        let target = {
            name: "target",
            value: 42,
        };
        let proxy = new Proxy(target, {
            has(trapTarget, key) {
                if (key === 'value') {
                    return false;
                } else {
                    return Reflect.has(trapTarget, key);
                }
            }
        });
        console.log('value' in proxy);  // false
        console.log('name' in proxy);   // true
        console.log('toString' in proxy);   // true
    })();

    // - 8.1 原型代理的陷阱函数如何工作
    (function () {
        let target = {};
        let proxy = new Proxy(target, {
            getPrototypeOf(trapTarget) {
                return null;
            },
            setPrototypeOf(trapTarget, proto) {
                return false;
            }
        });
        // - Object.prototypeOf(target) 是直接调用内置方法来判断 target 的原型.
        let targetProto = Object.getPrototypeOf(target);
        // - proxy 代理中的 getPrototypeOf() 方法拦截了 Object.getPrototypeOf()
        //   方法的默认操作, 所以这里返回 null.
        let proxyProto = Object.getPrototypeOf(proxy);
        console.log(proxyProto);    // null

        console.log(targetProto === Object.prototype);  // true
        console.log(proxyProto === Object.prototype);   // false

        // - 成功
        Object.setPrototypeOf(target, {});

        // - 抛出错误
        Object.setPrototypeOf(proxy, {});
    })();
</script>
</body>
</html>
