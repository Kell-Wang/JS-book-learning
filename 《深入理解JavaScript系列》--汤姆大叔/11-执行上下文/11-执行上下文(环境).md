# 11. 执行上下文(Execution Context)和执行栈(Call Stack)

- Tip: 这一章节的内容, 为几篇文章的混合.
- Tip02: 执行上下文有的文章也叫 "执行环境" 本文按照汤姆老师的称呼来.
- 参考文章有:  
    + [11.执行上下文](https://www.cnblogs.com/TomXu/archive/2012/01/13/2308101.html)
    + [深入理解JS中的执行环境和执行栈](http://lht.ren/article/18/)
    + [解读 JS引擎、运行时和堆栈调用](https://www.itcodemonkey.com/article/1597.html)


## 目录 (Catalog)
- 11.1 什么是执行上下文和执行栈? 
- 11.2 什么是可执行代码 (Executable Code)?
- 11.3 执行上下文的类型
    + 11.3.1 全局执行上下文
    + 11.3.2 函数执行上下文
    + 11.3.3 eval 函数执行上下文 
- 11.4 执行栈(Call Stack)



## 生词 (New Words)
- **execution [ˌeksɪ'kjuːʃ(ə)n] ---n.执行，实行**
- **executable ['eksikju:təbl] --adj.可执行的，实行的**
    + C++ Executable  C++ 可执行文件
- **stack [stæk] --n.堆,堆叠。 --v.堆积**
- **recursive [rɪ'kɜːsɪv] --adj.递归的；循环的** 
    + recursive algorithm 递归算法
    + recursive function 递归函数


## 内容 (Content)

### 11.1 什么是执行上下文(Execution Context)和执行栈(Call Stack)? 
- 执行上下文也可以理解为当前代码的执行环境.
- 每次当 控制器{1} 转到 ECMAScript 可执行代码的时候{2}, 即会进入一个执行上下文
  (ExecutionContext)。 执行上下文(简称：EC) 是 ECMA-262 标准里的一个抽象概念，用于
  同可执行代码(executable code)概念进行区分。
    + {1} 控制器: 不知道到底指什么? 请教!!!.
    + {2} 即执行 JS 代码.
- 标准规范没有从技术实现的角度定义 Execution Context 的准确类型和结构，这应该是具体实现
  ECMAScript 引擎时要考虑的问题。(Tip: 执行上下文和执行栈都是 JS 引擎实现的功能.)
- 活动的执行上下文组(active execution context group)在逻辑上组成一个堆栈, 即执行栈.
  堆栈底部永远都是全局上下文(global context), 而顶部就是当前(活动)的上下文。堆栈在
  执行上下文类型进入和退出的时候被修改(推入(push) 或 弹出(pop))

### 11.2 什么是可执行代码 (executable code)?
- Added 内容: ([资料来源](https://www.cnblogs.com/yuanjiangw/p/10482542.html)) 
    + 可执行代码是指将目标代码(object code) 连接后形成的代码,简单来说就是机器能够
      直接执行的代码.
    + 目标代码指计算机中编译器或汇编器处理源代码后生成的代码, 它一般由机器代码或接近于
      机器语言的代码组成. 在计算机科学中, 可执行代码是指将目标代码连接后形成的代码, 
      简单来说是机器能够直接执行的代码. 可执行代码一般是可执行文件的一部分.
- 可执行代码的类型这个概念与执行上下文的概念是有关系的. 在某些时刻, 可执行代码与
  执行上下文完全有可能是等价的.  
- 例如, 我们可以定义 执行上下文堆栈(Execution Context Stack) 是一个数组:  
  Tip: 执行上下文堆栈也即是下面要讲的执行栈, 浏览器中称作 Call Stack)
  ```base
    ExecutionContextStack =  [];
  ```

### 11.3 执行上下文的类型有 3 种:
#### 11.3.1 全局执行上下文(global context): 
- JS 引擎执行时首先进入的环境, 全局执行上下文首先会创建一个全局对象 (浏览器中是 window,
  Node 中是 global), 并把 this 的值设置到此全局对象中. 程序中只存在一个全局执行上下文. 
- 这种类型的代码是在 "程序" 级处理的: 例如加载外部的 JS 文件 或者 本地
  `<script></script>` 标签内的代码. **全局代码不包含任何 function 体内的代码.** 
- 在初始化 (程序启动) 阶段, ExecutionContextStack 是这样的:
  ```base
    ExecutionContextStack = [
        globalContext
    ];
  ```
#### 11.3.2 函数执行上下文(function context)
- 每个函数都有自己的执行上下文, 但函数执行上下文只在函数被调用的时候才会被创建. 
  JS引擎内可以有任意多个函数执行上下文.
- 当函数被调用时, 函数代码被推入(push)到 执行上下文堆栈(ExecutionContextStack)中
  [Tip: 也即是浏览器中的 "执行栈 (Call Stack)"]. 需要注意的是,具体的函数代码
  不包括内部函数(inner functions)代码. 如下所示, 我们使用递归(recursive)使函数
  自己调用自己一次: 
  ```js
    (function foo(flag) {
        // - 如果 flag 为 true 退出函数执行
        if (flag) {
            return;
        }
        foo(true);
    })();
  ```
  那么, ExecutionContextStack 如下方式被改变 (伪代码, 展示执行原理):
  ```base
    // - 第一次 foo 被调用时(tip: 第一次 foo 是函数自执行的 ()();)
    ExecutionContextStack = [
        <foo> functionContext,
        globalContext
    ];

    // - foo 的递归被调用时
    ExecutionContextStack = [
        <foo> functionContext - recursively
        <foo> functionContext
        globalContext
    ];
  ```
  每次 return 的时候, 都会退出当前执行上下文, 相应的函数会被从执行上下文堆栈中弹出,
  栈指针会自动移动位置, 这是一个典型的堆栈实现方式 一个抛出的异常如果没被截获的话也有可能
  从一个或多个执行上下文退出. 相关代码执行完毕后, 执行上下文栈只会包含全局执行上下文,
  一直到整个应用程序结束.
#### 11.3.3 eval 函数执行环境
- 在 eval 函数中执行代码也会获得它自己的执行环境，但是eval并不常用, 所以不讨论。
- eval 代码有点儿意思。它有一个概念: 调用上下文(calling context). 例如，eval函数
  调用的时候产生的上下文。eval(变量或函数声明)活动会影响调用上下文(calling context)。
- 下面内容省略...

### 11.4 执行栈(Call Stack)
- Note: 执行栈也即是上面讲的 "执行上下文栈(Execution Context Stack)", 上面不够详细,
  这里补充说明.
- 执行栈, 在其他编程语言中也被称为调用栈, 它是一种 LIFO (后进先出, 和数组类似) 的数据结构,
  被用于在代码执行阶段存储所有创建过的执行环境.
  + Tip: 关于栈数据结构的详细讲解见:
    `《学习JavaScript数据结构与算法》/chapter04-栈/chapter04-栈.md`
- 现在来看 3 个示例:
#### (1) 基本示例, 不牵扯到闭包
- 示例代码:
  ```js
    function multiply(x, y) {   // {1}
        return x * y;
    }
    function printSquare(x) {   // {2}
        let s = multiply(x, x); // {3}
        console.log(s);         // {4}
    }
    printSquare(5);             // {5}
  ```
- 执行顺序解说: 
    + (0) JS 代码执行首先把 全局执行下文(global context) 推入(push)到执行栈
      (Call Stack) 中 (tip: 下图略过了 globalContext).
    + (1) 接着执行{5} 调用 printSquare() 函数, 函数被调用便会立即创建函数执行上下文(
      functionContext), 接着便把函数推入到执行栈中, 即下图的 `Step1`.
    + (2) 函数入栈后便会开始执行函数体内的代码, 行{3} 被执行, 来看一下行{3}代码:
      调用 multiply 函数, 并把返回值赋值给变量 s; 既然 multiply函数被调用, 
      便会创建相应的函数执行上下文, 接着此函数被推入到执行栈中(即下图的 `Step2`),  
      然后执行 multiply 函数体内的代码, multiply 函数体内只有一行代码,
      return 一个返回值并把返回值赋值给变量 s , 这样 行{3}执行完毕, multiply
      函数被推出(pop)执行栈, 同时退出当前函数执行上下文.
    + (3) 接着执行 行{4}, 由于 console 是浏览器引擎内置的对象, 所以 console.log(s)
      也被推入到执行栈(即下图的 `Step3`). (Tip: console 对象是 Web API 提供的接口,
      log()方法的源码我们看不到, 暂时先不表, 在下面的示例三中会进一步解说.)
    + (4) console.log 入栈执行输出后完毕, 接着被推出执行栈(即下图的 `Step4`).
    + (5) 行{4} 执行完毕之后, printSquare() 函数体内代码完全执行, 接着便被推出执行栈
      (即下图的 `Step5`); 至此函数被全部推出执行栈, 现在栈中只有全局执行环境,
      若此时JS代码也全部执行完毕, 全局执行上下文随程序一起结束.
- 执行图:
  <img src="./images/01.png" style="margin-left:0; width:96%;">
  
#### (2) **带有闭包的执行栈示例**
- 示例代码: (tip: 此代码来自《JavaScript设计模式与编程实践》)
  ```js
    Function.prototype.before = function(beforefn) { // {1}
        let _self = this;                            // {2}
        return function() {                          // {3} - 标记为 r1 
            beforefn.apply(this, arguments);         // {4} - 标记为 r2
            return _self.apply(this, arguments);     // {5}
        }
    };
    Function.prototype.after = function(afterfn) {  // {6}
        let _self = this;                           // {7}
        return function() {                         // {8} - 标记为 r3
            let ret = _self.apply(this, arguments); // {9}
            afterfn.apply(this, arguments);         // {10}
            return ret;                             // {11} - 标记为 r4
        }
    };
    let func = function() {           // {12} - 匿名函数标记为 f2
        console.log(2);               // {13}
    };
    func = func.before(               // {14}
        function() {console.log(1)}   // {15} - 标记为 f1
    );      
    func = func.after(                // {16}
        function() {console.log(3)}   // {17} - 标记为 f3
    );
    func();                           // {18}
  ```
  
- 执行顺序解说:
    
    + (0) JS 代码执行首先把全局执行上下文(global context) 推入到执行栈中,
    
- 执行图:
```base
          Step1  
    +----------------+      +----------------+
    | -------------- |      | -------------- | 
    | -------------- |      |  :----------:  |
    | -------------- |      |                |
    | -------------- |      |                |
    | Global Context |      | Global Context |
    +----------------+      +----------------+
```

    


​    

#### (3) **带有回调函数(异步)的执行栈示例**