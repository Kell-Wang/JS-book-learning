# 11. 执行上下文(Execution Context)和执行栈(Call Stack)

- Tip: 这一章节的内容, 为几篇文章的混合.
- Tip02: 执行上下文有的文章也叫做 "执行环境" 本文按照汤姆老师的称呼来.
- 参考文章有:  
    + [11.执行上下文](https://www.cnblogs.com/TomXu/archive/2012/01/13/2308101.html)
    + [深入理解JS中的执行环境和执行栈](http://lht.ren/article/18/)
    + [解读 JS引擎、运行时和堆栈调用](https://www.itcodemonkey.com/article/1597.html)


## 目录 (Catalog)
- 11.1 什么是执行上下文和执行栈? 
- 11.2 什么是可执行代码 (Executable Code)?
- 11.3 执行上下文的类型
    + 11.3.1 全局执行上下文
    + 11.3.2 函数执行上下文
    + 11.3.3 eval 函数执行上下文 
- 11.4 执行栈(Call Stack)



## 生词 (New Words)
- **execution [ˌeksɪ'kjuːʃ(ə)n] ---n.执行，实行**
- **executable ['eksikju:təbl] --adj.可执行的，实行的**
    + C++ Executable  C++ 可执行文件
- **stack [stæk] --n.堆,堆叠。 --v.堆积**
- **recursive [rɪ'kɜːsɪv] --adj.递归的；循环的** 
    + recursive algorithm 递归算法
    + recursive function 递归函数


## 内容 (Content)

### 11.1 什么是执行上下文(Execution Context)和执行栈(Call Stack)? 
- 执行上下文也可以理解为当前代码的执行环境.
- 每次当 控制器{1} 转到 ECMAScript 可执行代码的时候{2}, 即会进入一个执行上下文
  (ExecutionContext)。 执行上下文(简称：EC) 是 ECMA-262 标准里的一个抽象概念，用于
  同可执行代码(executable code)概念进行区分。
    + {1} 控制器: Web 浏览器内部的控制程序.
    + {2} 即执行 JS 代码, 因为一个功能完备的 Web 浏览器其内核又分为 2 部分: 渲染引擎
      (layout engineer / Rendering Engine) 和 JS 引擎.
- 标准规范没有从技术实现的角度定义 Execution Context 的准确类型和结构，这应该是具体实现
  ECMAScript 引擎时要考虑的问题。(Tip: 执行上下文和执行栈都是 JS 引擎实现的功能.)
- 活动的执行上下文组(active execution context group)在逻辑上组成一个堆栈, 即执行栈.
  堆栈底部永远都是全局上下文(global context), 而顶部就是当前(活动)的上下文。堆栈在
  执行上下文类型进入和退出的时候被修改(推入(push) 或 弹出(pop))

### 11.2 什么是可执行代码 (executable code)?
- Added 内容: ([资料来源](https://www.cnblogs.com/yuanjiangw/p/10482542.html)) 
    + 可执行代码是指将目标代码(object code) 连接后形成的代码,简单来说就是机器能够
      直接执行的代码.
    + 目标代码指计算机中编译器或汇编器处理源代码后生成的代码, 它一般由机器代码或接近于
      机器语言的代码组成. 在计算机科学中, 可执行代码是指将目标代码连接后形成的代码, 
      简单来说是机器能够直接执行的代码. 可执行代码一般式可执行文件的一部分.
- 可执行代码的类型这个概念与执行上下文的概念是有关系的. 在某些时刻, 可执行代码与
  执行上下文完全有可能是等价的.  
- 例如, 我们可以定义 执行上下文堆栈(Execution Context Stack) 是一个数组:  
  Tip: 执行上下文堆栈也即是下面要讲的执行栈, 浏览器中称作 Call Stack)
  ```base
    ExecutionContextStack =  [];
  ```

### 11.3 执行上下文的类型有 3 种:
#### 11.3.1 全局执行上下文(global context): 
- JS 引擎执行时首先进入的环境, 全局执行上下文首先会创建一个全局对象 (浏览器中是 window,
  Node 中是 global), 并把 this 的值设置到此全局对象中. 程序中只存在一个全局执行上下文. 
- 这种类型的代码是在 "程序" 级处理的: 例如加载外部的 JS 文件 或者 本地
  `<script></script>` 标签内的代码. **全局代码不包含任何 function 体内的代码.** 
- 在初始化 (程序启动) 阶段, ExecutionContextStack 是这样的:
  ```base
    ExecutionContextStack = [
        globalContext
    ];
  ```
#### 11.3.2 函数执行上下文(function context)
- 每个函数都有自己的执行上下文, 但函数执行上下文只在函数被调用的时候才会被创建. 
  JS引擎内可以有任意多个函数执行上下文.
- 当函数被调用时, 函数代码被推入(push)到 执行上下文堆栈(ExecutionContextStack)中
  [Tip: 也即是浏览器中的 "执行栈 (Call Stack)"]. 需要注意的是,具体的函数代码
  不包括内部函数(inner functions)代码. 如下所示, 我们使用递归(recursive)使函数
  自己调用自己一次: 
  ```js
    (function foo(flag) {
        // - 如果 flag 为 true 退出函数执行
        if (flag) {
            return;
        }
        foo(true);
    })();
  ```
  那么, ExecutionContextStack 如下方式被改变 (伪代码, 展示执行原理):
  ```base
    // - 第一次 foo 被调用时(tip: 第一次 foo 是函数自执行的 ()();)
    ExecutionContextStack = [
        <foo> functionContext,
        globalContext
    ];

    // - foo 的递归被调用时
    ExecutionContextStack = [
        <foo> functionContext - recursively
        <foo> functionContext
        globalContext
    ];
  ```
  每次 return 的时候, 都会退出当前执行上下文的, 相应地 ExecutionContextStack 就会弹出,
  栈指针会自动移动位置, 这是一个典型的堆栈实现方式 一个抛出的异常如果没被截获的话也有可能
  从一个或多个执行上下文退出. 相关代码执行完毕后, 执行上下文栈只会包含全局执行上下文,
  一直到整个应用程序结束.
#### 11.3.3 eval 函数执行环境
- 在 eval 函数中执行代码也会获得它自己的执行环境，但是eval并不常用, 所以不讨论。
- eval 代码有点儿意思。它有一个概念: 调用上下文(calling context). 例如，eval函数
  调用的时候产生的上下文。eval(变量或函数声明)活动会影响调用上下文(calling context)。
- 下面内容省略...

### 11.4 执行栈(Call Stack)
- Note: 执行栈也即是上面讲的 "执行上下文栈(Execution Context Stack)", 
  上面不够详细,这里补充说明.
- 执行栈, 在其他编程语言中也被称为调用栈, 它是一种 LIFO (后进先出, 和数组类似) 的数据
  结构, 被用于在代码执行阶段存储所有创建过的执行环境.
  + Tip: 关于栈数据结构的详细讲解见: `DataStructure-Algorithm-Learning/`
    `《学习JavaScript数据结构与算法》/chapter04-栈/chapter04-栈.md`
- 我们根据上面的讲解来看 2 个示例:
    + (1) 基本示例, 不牵扯到闭包
        - 示例代码:
          ```js
            function multiply(x, y) {       // {1}
                return x * y;
            }
            function printSquare(num) {     // {2}
                let s = multiply(num, num); // {3}
                console.log(s);             // {4}
            }
            printSquare(5);                 // {5}
          ```
        + 执行顺序解说: 
            - (0) JS 代码执行首先把 全局执行下文(global context) 推入(push)到
              执行栈(Call Stack) 中 (tip: 下图略过了 globalContext).
            - (1) 接着执行{5} 调用 printSquare() 函数, 函数被调用便会立即创建
              函数执行上下文(functionContext), 接着便把函数推入到执行栈中, 即
              下图的 Step1.
            - (2) 函数入栈后便会开始执行函数体内的代码, 行{3} 被执行, 先分析行{3}
              代码: 先调用 multiply 函数, 并把返回值赋值给变量 s; 既然 multiply
              函数被调, 用便会立马创建相应的函数执行上下文, 接着把此函数推入到执行栈中
              (即下图的 Step2),  接下来执行 multiply 函数体内的代码, return 一个
              返回值后结束执行, multiply 函数执行完之后会被推出(pop)执行栈, 同样也会
              释放相应的的函数执行上下文.
            - (3) 行{3} 执行完毕, 接着执行 行{4}, 由于 console 是浏览器引擎内置的
              对象, 所以 console.log() 也被推入到执行栈(即下图的 Step3).
            - (4) console.log 入栈后执行输出后完毕, 接着被推出执行栈(即下图的 Step4).
            - (5) 行{4} 执行完毕之后, printSquare() 函数体代码也执行完成, 接着便会
              被推出执行栈(即下图的 Step5)
          <img src="./images/01.png" style="margin-left:0; width:96%;">


    + (2) 带有闭包的执行栈示例
    + (3) 带有回调函数(异步)的执行栈示例